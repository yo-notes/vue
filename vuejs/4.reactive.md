# 4 Reactive（响应式）

本节继续上一节，从 `initState` 开始，深入探索 Vue 中的数据响应如何实现。

## data 的初始化

```js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

props 和 methods 在 data 之前初始化。

先看 `initData`

```js
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm) // 计算 data 真实值
    : data || {}
  if (!isPlainObject(data)) {
    // data 非对象，告警
  }
  // 检测是否与 props 或 methods 重名
  // 并且不是保留属性（_ 或 $ 开头）
  // 然后代理 data 属性的 get/set： proxy(vm, `_data`, key)
  // 这样如果 data:{a:1}，那么就可以通过 vm.a 直接操作，proxy 定义见下方
  // 最后是 observe `data`
  observe(data, true /* asRootData */)
}

const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

## 响应基础

一个简单的依赖收集示例（没有防止重复收集等考虑）：[reactive basics demo](./playgroun/reactive/)

接着 `initData` 继续看 `observe`：

```js
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__ // 避免重复观测一个数据对象
  } else if (
    shouldObserve && // 全局开关
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) && // 不可扩展对象：Object.preventExtensions() | Object.freeze() | Object.seal()
    !value._isVue // 非 Vue 实例对象
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```

当 `value` 是一个没有被观察过的对象时，初始化一个构造器 `Observer`：

```js
export class Observer {
  export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    // 区分数组、对象分别处理
  }

  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
```

对象的处理是基础，所以先查看 `defineReactive` 方法：

```js
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep() // 对每一个 key 都有自己的 dep
  // 跳过不可配置的属性
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }
  // 获取原 getter/setter 用来在新定义的 getter/setter 里调用，保证原读写操作不受影响
  const getter = property && property.get
  const setter = property && property.set
  // 
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

}
```